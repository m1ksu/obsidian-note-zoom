import { CachedMetadata, FrontMatterCache, View, MarkdownView, TFile, getFrontMatterInfo } from "obsidian"
import { NoteZoomPluginSettings } from "./settings"
import NoteZoomPlugin, { getViewZoom, invokeZoomChange, ZoomMethod } from "./main"

export class ZoomProperty {
	markdownView: MarkdownView
	metadataContainerElement: HTMLElement
	plugin: NoteZoomPlugin
	initialized: boolean = false
	propertyHiderStyle: HTMLElement | null | undefined

	zoomPropertyName() { return this.plugin.settings.zoomPropertyName }

	constructor(markdownView: MarkdownView, plugin: NoteZoomPlugin) {
		this.markdownView = markdownView
		this.plugin = plugin
		this.attemptInitialization()
		if (!this.initialized) this.waitForMetadataContainer()
	}

	unload() {
		this.changeMetadataVisibility(true)
	}

	async attemptInitialization() {
		if (this.initialized) return

		const metadataContainer = this.markdownView.containerEl?.querySelector(".metadata-container")
		if (!metadataContainer) return
		this.metadataContainerElement = metadataContainer as HTMLElement
		this.hideOrShowProperty()
		
		this.initialized = true
		setTimeout(() => {}, 0)

		this.plugin.registerEvent(
			this.markdownView.app.metadataCache.on("changed", async (file: TFile, data: string, cache: CachedMetadata) => {
				if (file == this.markdownView.file && cache.frontmatter?.hasOwnProperty(this.zoomPropertyName())) {
					const zoom = cache.frontmatter[this.zoomPropertyName()]

					if (zoom != getViewZoom(this.markdownView))
						invokeZoomChange(zoom, this.markdownView, ZoomMethod.Absolute)

					await this.reevaluateMetadataVisibility()
				}
			})
		)

		await this.addMutationObserverFunction((mutations) => {
			mutations.forEach(async (mutation) => {
				if (mutation.type == "attributes" && mutation.attributeName == "data-property-count")
					await this.reevaluateMetadataVisibility()
			})
		}, metadataContainer)

		await this.reevaluateMetadataVisibility()
	}

	zoomChanged(newZoom: number) {
		processFrontMatter(this.markdownView, (frontMatter) => {
			if (newZoom == 1 && frontMatter?.hasOwnProperty(this.zoomPropertyName()))
				delete frontMatter[this.zoomPropertyName()]
			else if (frontMatter)
				frontMatter[this.zoomPropertyName()] = newZoom
		})
	}

	waitForMetadataContainer() {
		this.addMutationObserverFunction((mutations, observer) => {
			mutations.forEach((mutation) => {
				if (mutation.type === "childList") {
					mutation.addedNodes.forEach((addedNode: Node) => {
						if (addedNode instanceof Element && addedNode.matches(".metadata-container")) {
							observer.disconnect()
							this.attemptInitialization()
							return
						}
					})
				}
			})
		}, this.markdownView.containerEl)
	}

	async addMutationObserverFunction(
		fn: (mutations: MutationRecord[], observer: MutationObserver) => void,
		element: Node,
		observerOptions: MutationObserverInit = { attributes: true }
	) {
		const observer = new MutationObserver((mutations) => fn(mutations, observer))
		observer.observe(element, observerOptions)
		this.markdownView.registerEvent({
			detach: () => observer.disconnect(),
		})
	}

	async reevaluateMetadataVisibility() {
		if (!this.metadataContainerElement) return;
		if (this.plugin.settings.hideZoomProperty == false) {
			if (this.metadataContainerElement.getAttribute("style")?.contains("display:none;"))
				this.changeMetadataVisibility(true)
			return;
		}

		if (!this.markdownView.file) {
			this.changeMetadataVisibility(true)
			console.error("No file?")
			return
		}

		const frontmatter = await getViewFrontMatter(this.markdownView)
		const zoomProperty = frontmatter?.hasOwnProperty(this.zoomPropertyName())

		if (zoomProperty && frontmatter && Object.keys(frontmatter).length == 1) {
			this.changeMetadataVisibility(false)
		} else {
			this.changeMetadataVisibility(true)
		}
	}

	changeMetadataVisibility(newVisibility: boolean) {
		return
		let oldStyle = this.metadataContainerElement.getAttr("style") ?? ""
		if (oldStyle != "" && !oldStyle.endsWith(";")) oldStyle += ";"

		let setStyle = (value: string) => this.metadataContainerElement.setAttr("style", value)

		const regex = /display:[^;]+;/g

		if (newVisibility == false) {
			const match = oldStyle.match(regex)
			if (!match) setStyle((oldStyle += "display:none;"))
			else setStyle(oldStyle.replace(regex, ""))
		} else {
			setStyle(oldStyle.replace(regex, ""))
		}
	}

	hideOrShowProperty() {
		return
		if (this.plugin.settings.hideZoomProperty == true) {
			this.propertyHiderStyle = this.markdownView.containerEl.createEl("style")
			this.propertyHiderStyle.innerHTML =
				(this.metadataContainerElement.getAttribute("style") ?? "") 
				+ `.metadata-property[data-property-key="${this.zoomPropertyName()}"] {display: none;}`
		} else {
			this.propertyHiderStyle?.remove()
		}
	}
}

async function getViewFrontMatter(view: MarkdownView): Promise<Record<any, any> | null> {
	if (!view.file) return null
	let returnValue: Record<any, any> | null = null
	await processFrontMatter(view, (frontMatter: Record<any, any>) => returnValue = frontMatter)
	return returnValue
}

async function processFrontMatter(markdownView: MarkdownView, fn: (frontMatter: Record<any, any>) => void) {
	if (!markdownView.file) return
	await markdownView.app.fileManager.processFrontMatter(markdownView.file!, (frontMatter: Record<any, any>) => {
		fn(frontMatter)
	})
}
