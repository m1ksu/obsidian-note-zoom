import { assert } from "console"
import { CachedMetadata, MarkdownView, TFile } from "obsidian"

export class ZoomProperty {
	markdownView: MarkdownView
	metadataContainerElement: HTMLElement
	// zoomPropertyElement: HTMLElement
	// zoomValueElement: HTMLElement
	zoomPropertyName: string
	_zoomValue: number = 1
	initialized: boolean = false

	constructor(markdownView: MarkdownView, zoomPropertyName: string) {
		this.markdownView = markdownView
		this.zoomPropertyName = zoomPropertyName
		this.attemptInitialization()
		if (!this.initialized) this.waitForMetadataContainer()
	}

	waitForMetadataContainer() {
		this.addMutationObserverFunction((mutations, observer) => {
			for (const mutation of mutations) {
				if (mutation.type === "childList") {
					mutation.addedNodes.forEach((addedNode: Node) => {
						if (addedNode instanceof Element && addedNode.matches(".metadata-container")) {
							observer.disconnect()
							this.attemptInitialization()
							return 
						}
					})
				}
			}
		}, this.markdownView.containerEl)
	}

	async attemptInitialization() {
		if (this.initialized) return

		const metadataContainer = this.markdownView.containerEl?.querySelector(".metadata-container")
		if (!metadataContainer) return
		this.metadataContainerElement = metadataContainer as HTMLElement

		this.initialized = true
		setTimeout(() => {}, 0)

		this.markdownView.app.metadataCache.on("changed", (file: TFile, data: string, cache: CachedMetadata) => {
			if (file == this.markdownView.file && cache.frontmatter?.hasOwnProperty(this.zoomPropertyName)) {
				console.log(cache.frontmatter[this.zoomPropertyName])
			}
		})

		this.addMutationObserverFunction((mutations) => {
			mutations.forEach(mutation => {
				if (mutation.type == "attributes" && mutation.attributeName == "data-property-count") 
					this.reevaluateMetadataVisibility() 
			});
		}, metadataContainer)

		// this.zoomPropertyElement = await this.getOrCreateZoomPropertyElement()!
		// this.zoomValueElement = this.getZoomValueElement()!
		// this.metadataContainerElement = this.markdownView.containerEl.querySelector(".metadata-container")!

		// this.attachZoomPropertyValueChangeObserver()
		// this.attachPropertiesElementVisibilityObserver()
		// this.reevaluateMetadataVisibility()
	}

	// async createZoomProperty(): Promise<HTMLElement> {
	// 	await processFrontMatter(this.markdownView, (frontmatter) => {
	// 		if (!frontmatter[this.zoomPropertyName]) frontmatter[this.zoomPropertyName] = 1
	// 	})
	// 	return this.getZoomPropertyElement()!
	// }

	// getZoomPropertyElement(): HTMLElement | null {
	// 	return this.markdownView.containerEl.querySelector(`[data-property-key=\"${this.zoomPropertyName}\"]`)
	// }

	// getZoomValueElement(): HTMLElement | null {
	// 	return this.zoomPropertyElement.querySelector(".metadata-property-value")
	// }

	// async getOrCreateZoomPropertyElement(): Promise<HTMLElement> {
	// 	const element: HTMLElement | null = this.getZoomPropertyElement()
	// 	return element ?? (await this.createZoomProperty())
	// }

	// get zoomValue(): Promise<number> {
	// 	return new Promise((resolve) => {
	// 		processFrontMatter(this.markdownView, (frontmatter) => {
	// 			resolve(frontmatter.zoom)
	// 		})
	// 	})
	// }

	async addMutationObserverFunction(
		fn: (mutations: MutationRecord[], observer: MutationObserver) => void,
		element: Node,
		observerOptions: MutationObserverInit = { attributes: true }
	) {
		const observer = new MutationObserver((mutations) => fn(mutations, observer))

		observer.observe(element, observerOptions)

		this.markdownView.registerEvent({
			detach: () => observer.disconnect(),
		})
	}

	// async attachZoomPropertyValueChangeObserver() {
	// 	this.addMutationObserverFunction((mutations) => {
	// 		mutations.forEach(async function (mutation) {
	// 			if (mutation.type === "attributes") {
	// 				const zoomValue = await this.zoomValue
	// 				const zoomProperty = mutation.target as HTMLElement
	// 				const zoomEvent = new CustomEvent<number>("zoomChanged", { detail: zoomValue })
	// 				this.markdownView.containerEl.dispatchEvent(zoomEvent)
	// 			}
	// 		})
	// 	}, this.zoomValueElement)
	// }

	// async attachPropertiesElementVisibilityObserver() {
	// 	const daddy = this
	// 	this.addMutationObserverFunction((mutations) => {
	// 		mutations.forEach(function (mutation) {
	// 			if (mutation.type === "attributes") {
	// 				if (mutation.attributeName != "data-property-count") return
	// 				daddy.reevaluateMetadataVisibility()
	// 			}
	// 		})
	// 	}, this.metadataContainerElement)
	// }

	reevaluateMetadataVisibility() {
		// const propertyCount = parseInt(this.metadataContainerElement.getAttr("data-property-count")!)

		if (!this.markdownView.file) {
			this.changeMetadataVisibility(true)
			console.error("No file?")
			return
		}

		const frontmatter = this.markdownView.app.metadataCache.getFileCache(this.markdownView.file!)?.frontmatter
		const zoomProperty = frontmatter?.hasOwnProperty(this.zoomPropertyName)
		// const zoomProperty = this.metadataContainerElement.querySelector('.metadata-property[data-property-key="zoom"]')

		if (zoomProperty && frontmatter && Object.keys(frontmatter).length == 1) {
			this.changeMetadataVisibility(false)
		} else {
			this.changeMetadataVisibility(true)
		}
	}

	changeMetadataVisibility(newVisibility: boolean) {
		let oldStyle = this.metadataContainerElement.getAttr("style") ?? ""
		if (oldStyle != "" && !oldStyle.endsWith(";")) oldStyle += ";"

		let setStyle = (value: string) => this.metadataContainerElement.setAttr("style", value)

		const regex = /display:[^;]+;/g

		if (newVisibility == false) {
			const match = oldStyle.match(regex)
			if (!match) setStyle((oldStyle += "display: none;"))
			else setStyle(oldStyle.replace(regex, ""))
		} else {
			setStyle(oldStyle.replace(regex, ""))
		}
	}
}

async function processFrontMatter(markdownView: MarkdownView, fn: (frontmatter: Record<any, any>) => void) {
	if (!markdownView.file) return
	await markdownView.app.fileManager.processFrontMatter(markdownView.file!, (frontmatter: Record<any, any>) => {
		fn(frontmatter)
	})
}
